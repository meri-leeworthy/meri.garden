---
aliases:
  - discrete logarithm
---
$$\log_x​(x) = 1$$

The discrete logarithmic problem is a hard problem that has been used in the design and implementation of encryption algorithms in cryptography. Before we outline the hard problem, let's first recap some of the foundational mathematical concepts.

According to [[Euler's totient function and Euler's theorem|Euler's totient function]], the following holds true:

$$a^{ϕ(n)} ≡ 1 \mod n$$

Where _a_ and _n_ are relatively prime integers and Φ(_n_) represents the number of positive numbers less than n that are relatively prime to n.

We can rewrite the equation as follows:

$$a^m ≡ 1\mod n$$

Where _m = Φ(n)_, and can be defined as:

- the order of a (mod n)
    
- the exponent to which a belongs to (mod n)
    
- the length of the period generated by a.
    

The description of _m_ here is of particular importance. To illustrate this better, consider the image shown below, which outlines all the powers of _a mod 19_.

![](../public/094833915c0d354a5245decfacbeeb5e.png)

What we can observe in the image is that for a given simplistic _n = 19_, since n is prime, all numbers less than n are relatively prime to n. Furthermore, for every value assigned to a < 19, we can obtain the residue modulo n. What is important to note is that ==after a certain number of executions, the residue pattern repeats==. If it is not obvious, take a closer look at the shaded component in the image for each line. The shaded component represents the repeating residue pattern.

Extending this further, we can stipulate that _Φ(n)_ is the maximum possible exponent that can belong to a number. However, as evident in the image above, the maximum exponent doesn't necessarily guarantee a residue pattern that doesn't repeat. When a number does have a residue pattern of the order _Φ(n)_, this number is called the **primitive root** of _n_. This implies that if _a_ is a primitive root of _n_, then

$$a, a^2, a^3, ... , a^{ϕ(n)}$$

are all distinct (mod _n_) and are also relatively prime to _n_.

From this we can note that primitive roots for 19 are 2, 3, 10, 13, 14, and 15.

**Note:** It is important to note that not all integers will have primitive roots.

# Logarithmics for modular arithmetic

Generally, the calculation of the log is the inverse of the exponentiation function.

$$y = x\log⁡_x(y)$$

The above equation defines the calculation of a log for a value _y_, and a base _x_, where _x > 1_.

Furthermore, the following properties pertaining to logarithms hold:

$$\log⁡_x(1) = 0$$

$$\log⁡_x(x) = 1$$

$$\log⁡_x(yz) = \log⁡_x(y) + \log_⁡x(z)$$

$$log⁡_x(yr) = r ⋅ log⁡_x(y)$$

Applying this to the earlier concept of primitive roots, we know that a primitive root _a_ for some prime number _p_ produces a residue ranging from _1_ to _(p - 1)_ exactly once for all values of a from _1_ to _(p - 1)_. Hence, applying Euler's totient function again, we know that there exists some _b_, such that

b ≡ r (mod p)   for some r, where 0 ≤r ≤(p − 1)b ≡ r (mod p)   for some r, where 0 ≤r ≤(p − 1)

From modular arithmetic, we can further stipulate that there exists some exponent _i_ for a primitive root _a_ of _p_, such that

b ≡ ai (mod p)  , where 0 ≤i ≤(p − 1)b ≡ ai (mod p)  , where 0 ≤i ≤(p − 1)

From this calculation, we refer to exponent _i_ as the **discrete logarithm** of the number _b_ for the base _a (mod p)_. We denote this as

$$d\log⁡_{a,p}(b)$$

Consider the following scenario for some prime _p_ and a primitive root _a_.

$$x = ad\log⁡_{a,p}(x) \mod p  $$$$   y = ad\log⁡_{a,p}(y) \mod p $$$$    xy = ad\log⁡_{a,p}(xy) \mod p$$

Following modular arithmetic multiplication rules:

$$xy \mod p = [(x \mod p)(y \mod p)] \mod p$$

 $$ad\log⁡_{a,p}(xy) \mod p = [(ad\log⁡_{a,p}(x) \mod p)(ad\log⁡_{a,p}(y) \mod p)] \mod p $$

 adlog⁡a,p(xy) mod p = (adlog⁡a,p(x)+dlog⁡a,p(y)) mod p adloga,p​(xy) mod p = (adloga,p​(x)+dloga,p​(y)) mod p

But revisiting Euler's theorem again:

aϕ(n) ≡ 1 (mod n)

Any _z_, a positive integer, can be represented as follows:

z = q +kϕ(n)   , 0 ≤q <ϕ(n)

Therefore,

az = aq (mod n)    , if z ≡ q (mod ϕ(n))

Applying the above to the preceding equation:

dlog⁡a,p(xy) ≡ [dlog⁡a,p(x) + dlog⁡a,p(y)](mod ϕ(p))

Generalising the above we obtain:

dlog⁡a,p(yr) ≡ [r ⋅ dlog⁡a,p(y)](mod ϕ(p))

## Discrete logarithmic problem

Applying the above to determine the discrete logarithm for all the primitive roots of 19, we obtain the following:

- Discrete log to base 2, modulo 19
    

![](https://static.edusercontent.com/files/z5FZJ1gVRr22eQCr4Mg3ogFE)

- Discrete log to base 3, modulo 19
    

![](https://static.edusercontent.com/files/WomTNXWLQLdALueR4lgG2a5R)

- Discrete log to base 10, modulo 19
    

![](https://static.edusercontent.com/files/xqqciO6OHVVzWJUqtOyK8LHA)

- Discrete log to base 13, modulo 19
    

![](https://static.edusercontent.com/files/bSaWTdz7lXemGTnIkaJq4pHB)

- Discrete log to base 14, modulo 19
    

![](https://static.edusercontent.com/files/jCEHqiVYprqbOa0ZecJKwVLP)

- Discrete log to base 15, modulo 19
    

![](https://static.edusercontent.com/files/DELubvOVjupHfZNlkDZR7PMw)

From this, we can observe that in order to calculate the discrete logarithm we perform the following calculation for some base _g_, exponent _x_, and prime _p_:

y ≡ gx mod py ≡ gx mod p

We can easily observe that given the values of _g_, _x_, and _p_, it is relatively easy to determine the value of _y_. However, the discrete logarithmic problem stipulates that, given _y_, _g_, and _p_, it is difficult to determine the value of _x_.

The magnitude of difficulty is comparable to the integer factorisation algorithms, but the rationale behind using the discrete logarithmic problem to design cryptographic algorithms is that, unlike the integer factorisation algorithm, which can be implemented on a quantum computer, no known algorithm exists to solve the discrete logarithmic problem in P.